import logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('horror')
class Tag(object):
    name = 'html'

    def __init__(self, *args, **attr):
        self._children = []
        self.attr = attr
        self.sub = args
        self._dac.append_to_current(self)

    def __enter__(self):
        self._dac.set_current(self)
        logger.debug('enter')

    def __exit__(self, type, value, traceback):
        self._dac.pop_current(self)
        logger.debug('exit')

    @property
    def children(self):
        return ''.join([child.render() for child in self._children])

    def render_attributes(self):
        if not self.attr:
            return ''

        attrlist = [ '%s="%s"' % (k, v)for k,v in self.attr.items()]
        res = ' ' +  ' '.join(attrlist)
        return res

    def render_sub(self):
        return ''.join(self.sub)

    def render(self):
        logger.debug('render element : %s',  self.__class__)
        return "<%s%s>%s%s</%s>" % (self.name, self.render_attributes(), self.children, self.render_sub(), self.name)

    def __repr__(self):
        logger.debug(self.name)
        return self.name


class T(object):
    def __init__(self):
        self.__roots__ = []
        self.__current__ = None
        self.__previous__ = []

    def set_current(self, tag):
        if self.__current__:
            self.__previous__.append(self.__current__)
        self.__current__ = tag

    def pop_current(self, tag):
        if self.__previous__:
            self.__current__ = self.__previous__.pop()

    def append_to_current(self, tag):
        if self.__current__ :
            self.__current__._children.append(tag)
        else:
            self.__roots__.append(tag)

    def render(self):
        return '\n'.join(root.render() for root in self.__roots__)

    def __getattr__(self, attribute):
        logger.debug('getattr %s %s', attribute, self.__dict__.keys())
        if attribute in CustomTagMeta.registred_tags:
            #return type( attribute, (CustomTagMeta.registred_tags[attribute],), {'_dac': self}) # ReRegister class each time
            klass = CustomTagMeta.registred_tags[attribute]
            klass._dac = self #FIXME : Will probably pose problem with multiple documents, since we modify class attribute
            #Maybe we should return a function so it can get called?
            return klass
        return type('AutoGenerated_'+ attribute, (Tag,), {'name': attribute, '_dac': self})

class CustomTagMeta(type):
    registred_tags = {}
    def __new__(meta, classname, bases, classDict):
        klass = type.__new__(meta, classname, bases, classDict)
        logging.debug('Registred new tag type : %s', classname)
        meta.registred_tags[classname] = klass
        return klass

class CustomTag(Tag):
    __metaclass__ = CustomTagMeta

class MyLink(CustomTag):
    name = 'a' # FIXME should be able to inherit correctly direct tag but since they are under the instance of T
    def __init__(self, title, url=None):
        super(MyLink, self).__init__()
        self.sub = (title, )
        url = url if url else title
        self.attr = {'href':url}


class TagWithExtraRender(CustomTag):
    name = 'span'
    def render(self):
        r = super(TagWithExtraRender, self).render()
        return r + "<br/ >Added Text"

logger.debug(CustomTagMeta.registred_tags)

t = T()

projects = [
    ('projet1', 'url1'),
    ('projet2', 'url2'),

]
with t.html():
    with t.head():
        t.title('Ma page')
    with t.body():
        t.button('mon button', type='text')
        t.MyLink('http://perdu.com')
        t.h2('My projects')
        t.TagWithExtraRender('hello world')
        with t.ul():
            for title, url in projects:
                with t.li():
                    t.a(title, href=url)

print t.render()

